captool:
{
    timerPeriod = 60;                                       // timer of periodic events [sec], e.g., status logs and periodic file splits;  0 switches off (default: 30)

    controlPort = 44444;                                    // port at which captool listens to control commands (will try higher numbers if cannot bind)

    parserId = 0;                                           // 0-255; identification of the captool instance; if more instances started, each should have a different parserId

    statusManager: {
        filePrefix = "status";                              // prefix of status log files
        filePostfix = ".txt";                               // postfix of status log files
        bulkfilePrefix = "status";                          // prefix of status (bulk) log files
        bulkfilePostfix = ".blk";                           // postfix of status (bulk) log files
        outputEnabled = false;                              // enable/disable output
        bulkoutputEnabled = false;                          // enable/disable bulk output
    };

    moduleManager: {
        activeModule = "capture";                           // the packet listener module
    };

    fileManager: {
        splitFiles = true;                                  // if true, output files are split and postfixed
        outputDirectory = "/var/opt/ericsson/probe-controller/probe/captool//captool-0_out"; // root of all output files, except bulk files
        bulkoutputDirectory = "/var/opt/ericsson/probe-controller/probe/captool";       // root of all bulk output files (MS SQL bulk files)
        bulkfilePostfix = ".blk";                           // postfix of all bulk output files (including extension)
    };

    securityManager: {
        anonymize = false;                                  // true means that anything after a '?' charceter will be removed in URLs (default = false)
    };

    classification: {
        fileName = "conf/classification.xml";               // path to xml file describing traffic classification signatures and rules
    };

    modules:
    {

        capture:
        {
            type = "PcapCapture";

            connections = (                                 // 
                            ("default", "eth")              // *** IMPORTANT NOTE *** when using the KERNEL MODULE, packets should be forwarded directly to the IP module!
            );                                              //

            mode = "offline";                               // online/offline *** IMPORTANT NOTE *** when using the KERNEL MODULE, packets are read from a /proc file (need offline setting)
            input = "/var/opt/ericsson/captool/pcapMerger_14-3.pcap";                                 // devicename/filename can be an interface name (e.g. eth0, br0), pcap file name, named pipe, proc file
            maxPackets = 0;                                 // stop capture after reading that many packets. 0 means infinity (default setting)
        };

        eth:
        {
            type = "ETH";

            connections = (                                 // based on eth protocol field
                            (0x0800, "ip")                  // ip = 0x0800
            );

            gatewayAddressFile = "conf/gateway_macs.txt";   // The name of the file containing gateway MAC addresses (one address per line) - used to determin direction of packets
            setEquipmentID = true;                          // Use MAC address as equipment ID when set to true
        };

        ip:
        {
            type = "IP";

            connections = (                                 // based on ip protocol field
                            (17, "udp"),                    // udp = 17, tcp = 6
                            ( 6, "tcp"),                    //
                            ("default", "flow")             // packets from other transport layers can go directly to the flow module
            );

            idFlows = true;                                 // update IP address fields of flowID in packet? (has to be set for the inner IP header)
            defrag = true;                                  // enable / disable defragmentation (default = true)
            filterFragments = false;                        // drop non-first fragments when _not_ defragmenting (default = false)
//          ipv6Module = "ipv6_dump";                       // IPv6 not yet supported, but this parameter can be used to forward IPv6 traffic to another module (e.g. PcapOutput)
            iptype = "tunnel";                                // type of expected IP traffic ("tunnel" - only tunneling traffic, "user" - any traffic) used in the global status
        };

        udp:
        {
            type = "UDP";

            connections = (                                 // based on udp ports
                            ("default", "flow")             // all UDP traffic is forwarded to the flow module
            );

            idFlows = true;                                 // update port number fields of flowID in packet? (has to be set for the inner UDP header)
        };

        tcp:
        {
            type = "TCP";

            connections = (                                 // based on tcp ports
                            ("default", "flow")             // all TCP traffic is forwarded to the flow module
            );

            idFlows = true;                                 // update port number fields of flowID in packet? (has to be set for the inner TCP header)
        };

        flow:
        {
            type = "FlowOutputStrict";                      // FlowOutputStrict is the preferred Flow module. However, when packet direction information is not available
                                                            // (either from GTP-C messages or gateway MAC addresses), than you have to fall back to FlowOutput.

            connections = (
                            ("default", "dispatcher")       // has default connection only
            );

//          gtpControlModule = "gtpc";                      // to associate userId (IMSI), equipementId (IMEI) and APN to flows
            baseModule = "ip";                              // the lowest level module whose headers are already included when counting total packet length
            flowTimeout = 120;                              // 0: never; default: 0
            filePrefix = "flows";                           // prefix of output files
            filePostfix = ".txt";                           // postfix of output files (including extension)
            bulkfilePrefix = "flow";                        // prefix of (bulk) output files
            bulkfilePostfix = ".blk";                       // postfix of (bulk) output files (including extension)
            maxFileSize = 0;                                // maximum output file size; 0 = inf
            printHints = true;                              // specifies whether the list of classification hints should be printed in the flow log or not (default = false)
            storebytes = 0;                                 // store first this many uplink+downlink bytes per flow in the flowlog (default = 0)
            detailedStatistics = false;                     // set to true in order to generate detailed packet size and packet IAT statistics in the flow log (default = false)
            outputEnabled = false;                          // enables/disables flow log output
            bulkoutputEnabled = false;                      // enables/disables (bulk) flow log output
        };

        dispatcher:
        {
            type = "ClassifierDispatcher";

            connections = (
                            ("nonUdpTcpFirstPacket", "iptransportclassifier"),    // First packet of non UDP or TCP traffic
                            ("nonUdpTcp", "summary"),               // Any non UDP or TCP traffic (except first packet of "flow")
                            ("firstPacket", "portclassifier"),      // First packet of flow
                            ("firstReply", "serverportsearch"),     // First reply packet of the flow
                            ("firstFinal", "serverportsearch"),     // First packet of the flow where the flow is alread classified as final
                            ("unclassified", "http"),
                            ("classified", "summary"),              // Classified packets, no more classification required
                            ("recheck", "serverportsearch")         // Classified packet, but recheck every n = recheckFrequency packet
            );

            minPackets = 10;                                // Min number number of packets to be classified per flow (even if a "sure" hint is available earlier)
            maxPackets = 40;                                // Max number number of packets to be classified per flow (even if a "sure" hint is not yet available)
            recheckFrequency = 100;                         // Specify frequency of classification recheck (e.g. if set to 1000, then recheck will be performed for every 1000th packet of the flow)
        };

        iptransportclassifier:
        {
            type = "IPTransportClassifier";

            connections = (
                            ("default", "classassigner")
            );
        };

        portclassifier:
        {
            type = "PortClassifier";

            connections = (
                            ("default", "iprangeclassifier")
            );
        };

        iprangeclassifier:
        {
            type = "IPRangeClassifier";

            connections = (
                            ("default", "http")
            );
        };

        serverportsearch:
        {
            type = "ServerPortSearch";

            connections = (
                            ("default", "pphostsearch")
            );

            timeout = 120;                                  // Server port timeout in second (after receiving the last packet for the given server port), default = 120 sec
        };

        pphostsearch:
        {
            type = "P2PHostSearch";

            connections = (
                            ("default", "dispatcher2")
            );

            timeout = 900;                                  // Server port timeout in second (after receiving the last packet for the given server port), default = 900 sec
        };

        dispatcher2:
        {
            type = "ClassifierDispatcher";

            connections = (
                            ("unclassified", "http"),
                            ("classified", "classassigner") // Server port or P2P host search might add future hints
            );

            minPackets = 10;                                // Min number number of packets to be classified per flow (even if a "sure" hint is available earlier)
            maxPackets = 40;                                // Max number number of packets to be classified per flow (even if a "sure" hint is not yet available)
        };

        http:
        {
            type = "HTTP";

            connections = (
                            ("http", "dpi"),                // output for HTTP packets
                            ("non-http", "dpi")             // output for non-HTTP packets
            );

            httpHeadersToPrint = "User-Agent Host Server Content-Type";     // print these HTTP headers in the flow log (separated by spaces)
            printUrl = true;                                                // print request URL-s in the flow log (default = false)
            printHttpMethod = false;                                        // print HTTP GET/POST method in the flow log (default = false)
            printStatusCode = false;                                        // print status code in the flow log (default = false)
            maxBodySize = 20;                                               // parse this many bytes from HTTP body in addition to the headers (default = 20 bytes)
        };

        dpi:
        {
            type = "DPI";

            connections = (
                            ("default", "sequencenumber")
            );
        };

        sequencenumber:
        {
            type = "SequenceNumberClassifier";

            connections = (
                            ("default", "classassigner")
            );
        };

        classassigner:
        {
            type = "ClassAssigner";

            connections = (
                            ("default", "summary")
            );
        };

        summary:
        {
            type = "Summarizer";
            baseModule = "ip";                              // the lowest level module whose headers are already included when counting total packet length

            connections = (
                            ("default", "packetfilter")     // has default connection only
            );

            filePrefix = "summary";                         // prefix of bulk) output files
            filePostfix = ".txt";                           // postfix of output files (including extension)
            bulkfilePrefix = "summary";                     // prefix of (bulk) output files
            bulkfilePostfix = ".blk";                       // postfix of (bulk) output files (including extension)
            outputEnabled = false;                          // enable/disable output
            bulkoutputEnabled = true;                       // enable/disable bulk output
        };

        packetfilter:
        {
            type = "Filter";
            connections = (
                            ("pass", "packetfilter2"),      // Packets passing the filter will go there
                            ("drop", "null")                // Packets not passing the filter are dropped
            );

            bypass = true;                                  // Set to true in order to completely ignore the filter and pass all packets without processing
            mode = "filtering";                             // Mode selection (sampling | filtering)
            filtertype = "ip";                              // Specifies what to filter on (imsi | tac | ip | port)
            endpoint = "peer";                              // Specifies which endpoint the filtering is applied to (subscriber | peer)
            values = ["74.125.0.0/16", "72.14.192.0/18"];   // Comma separated set of values for which the filter will pass packets (ip range example)
        };

        packetfilter2:
        {
            type = "Filter";
            connections = (
                            ("pass", "flowpacket"),         // Packets passing the filter will go there
                            ("drop", "null")                // Packets not passing the filter are dropped
            );

            bypass = true;                                  // Set to true in order to completely ignore the filter and pass all packets without processing
            mode = "filtering";                             // Mode selection (sampling | filtering)
            filtertype = "port";                            // Specifies what to filter on (imsi | tac | ip | port)
            invert = true;                                  // Set to true to invert filtering decision
            transport = "tcp";                              // Allows further filtering on transport protocol (tcp | udp)
            endpoint = "peer";                              // Specifies which endpoint the filtering is applied to (subscriber | peer)
            values = [80, 8080, 443];                       // Comma separated set of values for which the filter will pass packets
        };

        flowpacket:
        {
            type = "FlowPacket";

            connections = (
                            ("default", "dump")             // has default connection only
            );

            baseModule = "ip";                              // the lowest level module whose headers are already included when counting total packet length
            filePrefix = "packets";                         // prefix of output files
            filePostfix = ".bin";                           // postfix of output files (including extension)
            maxFileSize = 0;                                // maximum output file size; 0 = inf
            outputEnabled = false;                          // enable / disable output
        };

        dump:
        {
            type = "PcapOutput";

            connections = (                                 // has default connection only
            );

            baseModule = "ip";                              // lowermost module to be dumped
            snapLength = 0;                                 // snaplength to use (0 = no snap)
            flowPackets = 20;                               // dump how many packets of each flow? (0 = all)
            fixHeaders = true;                              // fix invalidated headers? (e.g. after defragmentation)
            filePrefix = "user";                            // prefix of output files
            filePostfix = ".pcap";                          // postfix of output files (including extension)
            maxFileSize = 0;                                // maximum output file size; 0 = inf
            outputEnabled = false;                          // enable / disable output
        };
    };
};
