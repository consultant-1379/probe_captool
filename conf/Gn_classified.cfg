captool:
{
    timerPeriod = 60;                                       // timer of periodic events [sec], e.g., status logs and periodic file splits;  0 switches off (default: 30)

    controlPort = 44444;                                    // port at which captool listens to control commands (will try higher numbers if cannot bind)

    statusManager: {
        filePrefix = "status";                              // prefix of status log files
        filePostfix = ".txt";                               // postfix of status log files
    };

    moduleManager: {
        activeModule = "capture";                           // the packet listener module
    };

    fileManager: {
        splitFiles = true;                                  // if true, output files are split and postfixed
        outputDirectory = "out";                              // root of all output files
    };

    securityManager: {
        anonymize = false;                                  // true means that  1) IMSIs will be encrypted using a key from keyLocation  2) only TAC is kept from IMEI  3) anything after a '?' charceter will be removed in URLs (default = false)  4) subscriber IP addresses printed az xxx.yyy.0.0
        paranoid = false;                                   // Allow using futher obfuscation by hashing IMSIs from 15 digits to 13 digits (at the expense of possible collisions!). Only taken into account when anonymize is also true (default = false)
        keyLocation = "conf/key.txt";                       // path to key file
    };

    classification: {
        fileName = "conf/classification.xml";               // path to xml file describing traffic classification signatures and rules
    };

    modules:
    {

        // ----------------------------
        // Packet processing modules
        // ----------------------------

        capture:
        {
            type = "PcapCapture";

            connections = (                                 // 
                            ("default", "eth")              // *** IMPORTANT NOTE *** when using the KERNEL MODULE, packets should be forwarded directly to the IP module!
            );                                              //

            mode = "offline";                               // online/offline *** IMPORTANT NOTE *** when using the KERNEL MODULE, packets are read from a /proc file (need offline setting)
            input = "pipe";                                 // devicename/filename can be an interface name (e.g. eth0, br0), pcap file name, named pipe, proc file
            maxPackets = 0;                                 // stop capture after reading that many packets. 0 means infinity (default setting)
        };

        eth:
        {
            type = "ETH";

            connections = (                                 // based on eth protocol field
                            (0x0800, "ip")                  // ip = 0x0800
            );

//          gatewayAddressFile = "conf/gateway_macs.txt";   // The name of the file containing gateway MAC addresses (one address per line) - not needed for Gn config
        };

        ip:
        {
            type = "IP";

            connections = (                                 // based on ip protocol field
                            (17, "udp")                     // udp = 17, tcp = 6
            );

            idFlows = false;                                // update IP address fields of flowID in packet? (not the case for the outer IP header)
            defrag = true;                                  // enable / disable defragmentation (default = true)
            filterFragments = false;                        // drop non-first fragments when _not_ defragmenting (default = false)
//          ipv6Module = "ipv6_dump";                       // IPv6 not yet supported, but this parameter can be used to forward IPv6 traffic to another module (e.g. PcapOutput)
        };

        udp:
        {
            type = "UDP";

            connections = (                                 // based on udp ports
                            (2123, "gtpc"),                 // GTP-C traffic
                            (2152, "gtpu")                  // GTP-U traffic
            );

            idFlows = false;                                // update port number fields of flowID in packet? (not the case for the outer UDP header)
        };

        gtpc:
        {
            type = "GTPControl";

            connections = (                                 // GTP-C traffic does not need to be forwarded further
            );

            gsnIPModule = "ip";                             // which IP module to ask for packet's gsn ip address
            filePrefix = "pdp";                             // prefix of PDP output files
            filePostfix = ".txt";                           // postfix of PDP output files (including extension)
            maxFileSize = 0;                                // maximum output file size; 0 = inf.
            pdpTimeout = 36000;                             // length of inactivity period [sec] after which a PDP context is purged (0 means no timeouts at all)
//            samplingRatio = 0.5;                            // Specifies the ratio of subscribers whose traffic will pass via the IP filter in the kernel module
                                                            // This filter is controled by the GTPControl module.
        };

        gtpu:
        {
            type = "GTPUser";

            connections = (                                 // based on gtp type
                            (255, "imsifilter")             // t-pdu = 255
            );

            gsnIPModule = "ip";                             // which IP module to ask for packet's gsn ip address
            gtpControlModule = "gtpc";                      // which GTPControl module to ask for PDP context
        };

        imsifilter:                                         // ONLY FILTERING BASED ON IMSI IS POSSIBLE AT THIS POINT! FILTERING ON OTHER PARAMETERS SHOULD BE DONE __AFTER__ THE FLOW MODULE!
        {
            type = "Filter";
            connections = (
                            ("pass", "ip2"),                // Packets passing the filter will go there
                            ("drop", "null")                // Packets not passing the filter are dropped
            );

            bypass = true;                                  // Set to true in order to completely ignore the filter and pass all packets without processing
            mode = "sampling";                              // Mode selection (sampling | filtering)
            filtertype = "imsi";                            // Specifies what to filter on (imsi | tac | ip | port)
            ratio = 0.5;                                    // ratio of "imsi's" put to default output
        };

        ip2:
        {
            type = "IP";

            connections = (                                 // based on ip protocol field
                            (17, "udp2"),                   // udp = 17, tcp = 6
                            ( 6, "tcp2"),                   //
                            ("default", "flow")             // packets from other transport layers can go directly to the flow module
            );

            idFlows = true;                                 // update IP address fields of flowID in packet? (has to be set for the inner IP header)
            defrag = true;                                  // enable / disable defragmentation (default = true)
            filterFragments = false;                        // drop non-first fragments when _not_ defragmenting (default = false)
//          ipv6Module = "ipv6_dump";                       // IPv6 not yet supported, but this parameter can be used to forward IPv6 traffic to another module (e.g. PcapOutput)
        };

        udp2:
        {
            type = "UDP";

            connections = (                                 // based on udp ports
                            ("default", "flow")             // all UDP traffic is forwarded to the flow module
            );

            idFlows = true;                                 // update port number fields of flowID in packet? (has to be set for the inner UDP header)
        };

        tcp2:
        {
            type = "TCP";

            connections = (                                 // based on tcp ports
                            ("default", "flow")             // all TCP traffic is forwarded to the flow module
            );

            idFlows = true;                                 // update port number fields of flowID in packet? (has to be set for the inner TCP header)
        };

        flow:
        {
            type = "FlowOutputStrict";                      // FlowOutputStrict is the preferred Flow module. However, when packet direction information is not available
                                                            // (either from GTP-C messages or gateway MAC addresses), than you have to fall back to FlowOutput.

            connections = (
                            ("default", "dispatcher")       // has default connection only
            );

            gtpControlModule = "gtpc";                      // to associate userId (IMSI) and equipementId (IMEI) to flows (only used when 3GDTHack is set to true)
            directTunnelHack = false;                       // Indicates whether user and equipment IDs need to be assigned to flows and packets based on user IP addresses. 
                                                            // This is required in 3GDT configs where non-3GDT user plane traffic is captured from the IuPS and not from the Gn
                                                            // (hence PDP binding cannot be done based on TEIDs extracted from GTP-C)
            baseModule = "ip2";                             // the lowest level module whose headers are already included when counting total packet length
            flowTimeout = 120;                              // 0: never; default: 0
            filePrefix = "flows";                           // prefix of output files
            filePostfix = ".txt";                           // postfix of output files (including extension)
            maxFileSize = 0;                                // maximum output file size; 0 = inf
            printHints = true;                              // specifies whether the list of classification hints should be printed in the flow log or not (default = false)
            storebytes = 0;                                 // store first this many uplink+downlink bytes per flow in the flowlog (default = 0)
            detailedStatistics = false;                     // set to true in order to generate detailed packet size and packet IAT statistics in the flow log (default = false)
            outputEnabled = true;                           // enables/disables flow log output
            firstFlowModule = "p2pheuristics";              // the name of the first flow processing module which processes flows after they are timed out
                                                            // (similarly to the activeModule - being the main entry point for packet processing - the module specified here is the main entry point for flow processing)
        };

        dispatcher:
        {
            type = "ClassifierDispatcher";

            connections = (
                            ("nonUdpTcpFirstPacket", "iptransportclassifier"),    // First packet of non UDP or TCP traffic
                            ("nonUdpTcp", "summary"),               // Any non UDP or TCP traffic (except first packet of "flow")
                            ("firstPacket", "portclassifier"),      // First packet of flow
                            ("firstReply", "serverportsearch"),     // First reply packet of the flow
                            ("firstFinal", "serverportsearch"),     // First packet of the flow where the flow is alread classified as final
                            ("unclassified", "http"),
                            ("classified", "summary"),              // Classified packets, no more classification required
                            ("recheck", "serverportsearch")         // Classified packet, but recheck every n = recheckFrequency packet
            );

            minPackets = 10;                                // Min number number of packets to be classified per flow (even if a "sure" hint is available earlier)
            maxPackets = 40;                                // Max number number of packets to be classified per flow (even if a "sure" hint is not yet available)
            recheckFrequency = 100;                         // Specify frequency of classification recheck (e.g. if set to 1000, then recheck will be performed for every 1000th packet of the flow)
        };

        iptransportclassifier:
        {
            type = "IPTransportClassifier";

            connections = (
                            ("default", "classassigner")
            );
        };

        portclassifier:
        {
            type = "PortClassifier";

            connections = (
                            ("default", "iprangeclassifier")
            );
        };

        iprangeclassifier:
        {
            type = "IPRangeClassifier";

            connections = (
                            ("default", "http")
            );
        };

        serverportsearch:
        {
            type = "ServerPortSearch";

            connections = (
                            ("default", "p2phostsearch")
            );

            timeout = 120;                                  // Server port timeout in second (after receiving the last packet for the given server port), default = 120 sec
        };

        p2phostsearch:
        {
            type = "P2PHostSearch";

            connections = (
                            ("default", "dispatcher2")
            );

            timeout = 900;                                  // Server port timeout in second (after receiving the last packet for the given server port), default = 900 sec
        };

        dispatcher2:
        {
            type = "ClassifierDispatcher";

            connections = (
                            ("unclassified", "http"),
                            ("classified", "classassigner") // Server port or P2P host search might add future hints
            );

            minPackets = 10;                                // Min number number of packets to be classified per flow (even if a "sure" hint is available earlier)
            maxPackets = 40;                                // Max number number of packets to be classified per flow (even if a "sure" hint is not yet available)
        };

        http:
        {
            type = "HTTP";

            connections = (
                            ("http", "dpi"),                // output for HTTP packets
                            ("non-http", "dpi")             // output for non-HTTP packets
            );

            httpHeadersToPrint = "User-Agent Host Server Content-Type";     // print these HTTP headers in the flow log (separated by spaces)
            printUrl = true;                                                // print request URL-s in the flow log (default = false)
            printHttpMethod = false;                                        // print HTTP GET/POST method in the flow log (default = false)
            printStatusCode = false;                                        // print status code in the flow log (default = false)
            maxBodySize = 20;                                               // parse this many bytes from HTTP body in addition to the headers (default = 20 bytes)
        };

        dpi:
        {
            type = "DPI";

            connections = (
                            ("default", "sequencenumber")
            );
        };

        sequencenumber:
        {
            type = "SequenceNumberClassifier";

            connections = (
                            ("default", "classassigner")
            );
        };

        classassigner:
        {
            type = "ClassAssigner";

            connections = (
                            ("default", "summary")
            );
        };

        summary:
        {
            type = "Summarizer";
            baseModule = "ip2";                             // the lowest level module whose headers are already included when counting total packet length

            connections = (
                            ("default", "packetfilter")     // has default connection only
            );

            filePrefix = "summary"; 
            filePostfix = ".txt";
        };

        packetfilter:
        {
            type = "Filter";
            connections = (
                            ("pass", "packetfilter2"),      // Packets passing the filter will go there
                            ("drop", "null")                // Packets not passing the filter are dropped
            );

            bypass = true;                                  // Set to true in order to completely ignore the filter and pass all packets without processing
            mode = "filtering";                             // Mode selection (sampling | filtering)
            filtertype = "ip";                              // Specifies what to filter on (imsi | tac | ip | port)
            endpoint = "peer";                              // Specifies which endpoint the filtering is applied to (subscriber | peer)
            values = ["74.125.0.0/16", "72.14.192.0/18"];   // Comma separated set of values for which the filter will pass packets (ip range example)
//          values = ["35827901"];                          // Comma separated set of values for which the filter will pass packets (tac example)
        };

        packetfilter2:
        {
            type = "Filter";
            connections = (
                            ("pass", "flowpacket"),         // Packets passing the filter will go there
                            ("drop", "null")                // Packets not passing the filter are dropped
            );

            bypass = true;                                  // Set to true in order to completely ignore the filter and pass all packets without processing
            mode = "filtering";                             // Mode selection (sampling | filtering)
            filtertype = "port";                            // Specifies what to filter on (imsi | tac | ip | port)
            invert = true;                                  // Set to true to invert filtering decision
            transport = "tcp";                              // Allows further filtering on transport protocol (tcp | udp)
            endpoint = "peer";                              // Specifies which endpoint the filtering is applied to (subscriber | peer)
            values = [80, 8080, 443];                       // Comma separated set of values for which the filter will pass packets
        };

        flowpacket:
        {
            type = "FlowPacket";

            connections = (
                            ("default", "dump")             // has default connection only
            );

            baseModule = "ip2";                             // the lowest level module whose headers are already included when counting total packet length
            filePrefix = "packets";                         // prefix of output files
            filePostfix = ".bin";                           // postfix of output files (including extension)
            maxFileSize = 0;                                // maximum output file size; 0 = inf
            outputEnabled = false;                          // enable / disable output
        };

        dump:
        {
            type = "PcapOutput";

            connections = (                                 // has default connection only
            );

            baseModule = "ip2";                             // lowermost module to be dumped
            snapLength = 0;                                 // snaplength to use (0 = no snap)
            flowPackets = 20;                               // dump how many packets of each flow? (0 = all)
            fixHeaders = true;                              // fix invalidated headers? (e.g. after defragmentation)
            filePrefix = "user";                            // prefix of output files
            filePostfix = ".pcap";                          // postfix of output files (including extension)
            maxFileSize = 0;                                // maximum output file size; 0 = inf
            outputEnabled = false;                          // enable / disable output
        };

        // ----------------------------
        // Flow processing modules
        // ----------------------------

        p2pheuristics:
        {
            type = "P2PHeuristics";                         // 

            connections = (
                            ("default", "null")       // has default connection only
            );

            filePrefix = "p2p_heuristics";                       // prefix of output files
            filePostfix = ".txt";                           // postfix of output files (including extension)
            outputEnabled = true;                           // enables/disables log output
            ipMapSize = 127;                                // Size of bloom filter used to track the number of peers for each subscriber
        };
    };
};
